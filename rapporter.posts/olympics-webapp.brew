% Anonymous user
% Predictions about Olympics
% 2012

## TODO

  * when to drop a database based on few values (now set to `<10`)?
  * when to apply `weights`? Now applied to all.

<%=
## loading required packages
suppressPackageStartupMessages(library(XML))
suppressWarnings(suppressPackageStartupMessages(library(ggplot2)))
suppressPackageStartupMessages(library(gvlma))

## set options
eO <- evalsOptions()
pO <- panderOptions()
evalsOptions('width', 1100)
evalsOptions('height', 1100)
evalsOptions('graph.unify', TRUE)
panderOptions('table.split.table', Inf)
panderOptions('graph.symbol', 19)
panderOptions('graph.legend.position', 'top')
if (grepl("w|W", .Platform$OS.type))
    windowsFonts("Trebuchet MS" = windowsFont("Trebuchet MS"))
panderOptions('graph.fontfamily', "Trebuchet MS")
panderOptions('graph.background', 'transparent')

#' Pretty time printing
#' @param sec integer
#' @return character in \code{hours:minutes:seconds} format
#' @author Rapporter Dev Team
ms <- function(sec, D.time) {
	if (D.time == 1) {
    sapply(sec, function(sec) {
        sec <- round(sec)
        minute <- sec %/% 60
        if (minute > 59) {
            sec    <- sprintf("%02d", sec - minute * 60)
            hours  <- minute %/% 60
            minute <- sprintf("%02d", minute - hours * 60)
            paste(hours, minute, sec, sep=":")
        } else {
            sec <- sprintf("%02d", sec - minute * 60)
            paste(minute, sec, sep=":") }})
	} else 
		(sec)	
	}
}

#' Revert pretty time printing
#' @param sec character in \code{hours:minutes:seconds} format
#' @return numeric
rms <- function(text, D.time) {
	if (D.time == 1) {
    sapply(text, function(x) {
        x <- as.numeric(strsplit(x, ':')[[1]])
        if (length(x) == 1)
            return(x)
        if (length(x) == 2)
            return(x[1] * 60 + x[2])
        if (length(x) == 3)
            return(x[1] * 60^2 + x[2] * 60 + x[3])
    }, USE.NAMES = FALSE)
	} else
	(text)
}

#' Plot predictions
#' @param df a data frame with Year, Result columns
#' @param models predefined models' names to plot
plotPredictions <- function(df, models) {

    ## custom options
    panderOptions('graph.fontfamily', "Trebuchet MS")

    ## custom variables - satisfying our DRY needs
    Y         <- df[, 'Year']
    Y2012     <- c(Y, 2012)
    R         <- df[, 'Result']
    allvalues <- unlist(c(R, mget(paste0(models, '.predict'), envir = parent.frame())))
    ff        <- panderOptions('graph.fontfamily')
    fc        <- panderOptions('graph.fontcolor')
    gc        <- panderOptions('graph.colors')
    gt        <- panderOptions('graph.grid.lty')
    gcc       <- panderOptions('graph.grid.color')
    mn        <- mget(paste0(models, '.name'), envir = parent.frame())

    ## custom par settings
    par(
      family   = ff,
      lwd      = 2,
      pch      = panderOptions('graph.symbol'),
      col.axis = fc, col.lab = fc, col.main = fc, col.sub = fc,
      mar = c(3,4,3,3), family = ff, font = 4)

    ## results
    plot(Y, R, ylim = c(min(allvalues), max(allvalues)), xlim = c(min(Y), 2012), xaxt = "n", yaxt= "n", xlab = "", ylab = "", cex.lab = 2, cex.main = 2, cex.axis = 2, cex = 2, pch = 16, bg = "transparent", family = ff, font = 4)

    ## title
    mtext(paste0("Our predictions for the ", df$Event[1]), line = 1, side = 3, family = ff, cex=2.5, font=4, col ='black')

    ## get y axis's ticks
    ylime <- trunc(c(min(R), max(R)))
    yperiod <- trunc(diff(ylime)/5)
    if (diff(ylime) < 5) {
        ylime   <- round(c(max(R), min(R)), 2)
        yperiod	<- round(diff(ylime) / 5, 2)
    }
    ylime   <- c(ylime[1], ylime[1] + 1:5 * yperiod)

    ## draw x axis
    axis(1, at = Y2012, Y2012, cex = 2, family = ff, font=4)
    for (y in Y2012)
        abline(v = y, lty = gt, col = gcc, lwd = 0.5)

    ## draw y axis
    par(las = 1, family = ff)
    axis(2, at = ylime, ms(ylime, in.time), cex = 2, family = ff, font=4)
    for (y in ylime)
        abline(h = y, lty = gt, col = gcc, lwd = 0.5)

    points(Y, R)

    ## plotting models' lines & text
    for (m in models) {
        lines(Y2012, get(paste0(m, '.predict')), col = gc[which(m == models)])
        lines(Y2012, get(paste0(m, '.predict')), lwd = get(paste0(m, '.width')), col = paste0(gc[which(m == models)], '44'))
        points(2012, tail(get(paste0(m, '.predict')), 1), pch = 19, col = gc[which(m == models)], cex = 3.5)
        ## yy <- 2012 - round((2012-min(Y)) / 20) * (which(m == models) - 1)
        ## xx <- tail(get(paste0(m, '.predict')), 1) + (yperiod/5 * (2 - which(m == models)))
        yy <- 2012 - round((2012-min(Y)) / 25) * (2 - which(m == models))
        xx <- tail(get(paste0(m, '.predict')), 1) + (yperiod/7 * (which(m == models) - 1))
        text(yy, xx, ms(trunc(tail(get(paste0(m, '.predict')), 1)), in.time), col = gc[which(m == models)], cex = 2)
    }

    ## add a custom legend
    l.pos <- ifelse(xx < mean(R), 'topright', 'bottomright')
    mnames <- unlist(mget(paste0(models, '.name'), envir = parent.frame()), use.names = FALSE)
    legend(l.pos, mnames, lty = rep(1, times = length(models)), pch = rep(19, times = length(models)), col = rep(gc[1:length(models)], times = 2), adj = c(0, .6), cex = 2, text.col = 'black', text.width = strwidth(paste(mnames, collapse = ' ')))
}
%>



<%=
    ## datafile store
    dir.create(file.path(getwd(), 'reports', 'data'), recursive = TRUE, showWarnings = FALSE)
    datafile <- file.path(getwd(), 'reports', 'data', u)

    ## url should be set before calling this `brew` file in a format like: `SWI-240`
    uri <- strsplit(u, '-', fixed = TRUE)[[1]]
    url <- paste0('http://www.databaseolympics.com/sport/sportevent.htm?sp=', uri[1], '&enum=', uri[2])

    ## fetching data from \url{databaseolympics.com} if not cached
    if (!file.exists(datafile)) {
        d <- readHTMLTable(readLines(url, warn = FALSE), which = 2, header = TRUE)
        saveRDS(d, file = datafile)
    } else {
        d <- readRDS(datafile)
    }

    ## just dealing with the winners ATM
    golddata <- subset(d, Medal %in% "GOLD")
	## Just dealing with the same Events
	test.Event <- d$Event[!sapply(d$Event, grepl, "")]
	golddata <- subset(golddata, test.Event %in% tail(test.Event, 1))
	## Treat Relays duplications
	test.Year <- table(as.numeric(as.character(golddata$Year)))
	golddata <- golddata[c(1, 1+cumsum(as.numeric(test.Year[-length(test.Year)]))),]
	
    ## transforming data
    d$Event            <- as.character(d$Event)
    golddata$Year      <- as.numeric(as.character(golddata$Year))
    years              <- c(as.numeric(as.character(sort(unique(golddata$Year)))), 2012)
    golddata$Result    <- as.character(golddata$Result)
	in.time <- 1
	if (grepl(tail(golddata$Result, 1), ':')) {
		golddata$Result    <- rms(as.character(golddata$Result), in.time) 
	} else
		in.time <- 0
    rownames(golddata) <- NULL

    ## weights
    weights <- TRUE
%>

## <%=d$Event[1]%>

### Historical data

We have fetched some data from [databaseolympics.com](<%=url%>):

<%=golddata%>

<%=
    ## removing duplicated rows (we just need the Results)
    if (!all(table(golddata['Year']) == 1))
        golddata <- golddata[-which(duplicated(golddata['Year'])), ]
%>

<%if (nrow(golddata) > 6) { %>

### Non-linear model

And fitted a non-linear model on the winning times:

<%=
    ## fitting a non-linear model
    golddata$year2 <- golddata$Year**2
    golddata$year3 <- golddata$Year**3
    golddata$year4 <- golddata$Year**4
    if (weights) {
        nonLin     <- suppressWarnings(lm(Result ~ Year * year2 * year3 * year4, weights=((Year-min(Year)+4)/sum(Year-min(Year)+4)*length(Year)), data = golddata))
    } else {
        nonLin     <- suppressWarnings(lm(Result ~ Year * year2 * year3 * year4, data = golddata))
    }
    nonLin.name    <- 'power prediction'
    nonLin.predict <- suppressWarnings(predict(nonLin, newdata = data.frame(Year = years, year2 = years^2, year3 = years^3, year4 = years^4)))
    nonLin.width   <- (100 - ((1 - mean(summary(nonLin)$coefficients[, "Pr(>|t|)"]))^2 * 100)) + (1 - summary(nonLin)$adj.r.squared) * 100
    golddata2012   <- rbind(golddata, c(2012, rep(NA, times = ncol(golddata)-1)))
    golddata2012$nonLin <- nonLin.predict

    ## printing
    nonLin
%>

#### Validations of the Model Assumptions

<%=
pandoc.table.return(summary(gvlma(nonLin)), split.tables=Inf)
%>

#### Diagnostic plot

<%=
    par(mfrow = c(2, 2))
    +plot(nonLin)
%>

Where the adjusted R-squared equals to <%=summary(nonLin)$adj.r.squared%> with a p-value of <%=round(anova(nonLin)$'Pr(>F)'[1], 5)%>.

### Log-linear model

Our log-linear model looks like:

<%=
    ## fitting a log-linear model
    if (weights) {
        logLin      <- lm(log(Result) ~ Year, weights=((Year-min(Year)+4)/sum(Year-min(Year)+4)*length(Year)), data = golddata)
    } else {
        logLin      <- lm(log(Result) ~ Year, data = golddata)
    }
    logLin.name     <- 'simple prediction'
    logLin.predict  <- exp(predict(logLin, newdata = data.frame(Year = years)))
    logLin.width    <- (100 - ((1 - mean(summary(logLin)$coefficients[, "Pr(>|t|)"]))^2 * 100)) + (1 - summary(logLin)$adj.r.squared) * 100
    golddata2012$logLin <- logLin.predict

    ## printing
    logLin
%>

#### Validations of the Model Assumptions

<%=
pandoc.table.return(summary(gvlma(logLin)), split.tables=Inf)
%>

#### Diagnostic plot

<%=
    par(mfrow = c(2, 2))
    +plot(logLin)
%>

Where the adjusted R-squared equals to <%=summary(logLin)$adj.r.squared%> with a p-value of <%=round(anova(logLin)$'Pr(>F)'[1], 5)%>.

### ggplot2

Both models on a quick plot themed by our [backend](http://daroczig.github.com/pander/):

<%=ggplot(golddata2012) + geom_point(aes(x=Year, y=Result)) + geom_smooth(aes(x=Year, y=nonLin), alpha=0.2) + geom_smooth(aes(x=Year, y=logLin, col = "blue"), alpha=0.2, col = "red") + opts(title = d$Event[1]) + ylab("") + xlab("") + scale_y_continuous(labels = ms) + theme_bw() + opts(legend.position = "none")%>

### A complex plot

Both models on a complex plot:

<%=
    ## saving options as tweaking some internals
    evalsOptions('graph.unify', FALSE)
%><%=
    ## plotting
    models <- c('nonLin', 'logLin')
    plotPredictions(golddata, models)
%>

<% } else { %>

Not enought data to build a model.

<% } %>

<%=
    ## resetting options
    for (o in names(eO))
        evalsOptions(o, eO[[o]])
    for (o in names(pO))
        panderOptions(o, pO[[o]])
%>
